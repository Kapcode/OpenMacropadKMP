package com.kapcode.open.macropad.kmp.network.ktor\n\nimport com.kapcode.open.macropad.kmp.network.sockets.Model.DataModel\nimport com.kapcode.open.macropad.kmp.network.sockets.Model.MessageType\nimport io.ktor.client.*\nimport io.ktor.client.plugins.contentnegotiation.*\nimport io.ktor.client.plugins.websocket.*\nimport io.ktor.websocket.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.ClosedReceiveChannelException\n// import kotlinx.serialization.json.Json // Removed, using DataModel.Json\n\nclass KtorClient(\n    private val host: String = \"localhost\",\n    private val port: Int = 9999,\n    private val onMessageReceived: (DataModel) -> Unit = {},\n    private val onConnected: () -> Unit = {},\n    private val onDisconnected: () -> Unit = {},\n    private val onError: (Throwable) -> Unit = {}\n) {\n\n    private var client: HttpClient? = null\n    private var session: DefaultWebSocketSession? = null\n    private val scope = CoroutineScope(Dispatchers.Default)\n    private var receiveJob: Job? = null\n\n    private val encryptionManager = EncryptionManager()\n    private var isKeyExchangeComplete = false\n\n    fun connect() = scope.launch {\n        try {\n            client = HttpClient {\n                install(WebSockets)\n                install(ContentNegotiation) {\n                    json(DataModel.Json) // Use shared Json instance\n                }\n            }\n            session = client?.webSocketSession(host = host, port = port, path = \"/\")\n            log(\"WebSocket session established.\")\n\n            // Initiate key exchange: Send client's public key\n            val clientPublicKey = encryptionManager.initializeKeyExchange()\n            val publicKeyExchangeMessage = DataModel(messageType = MessageType.PublicKeyExchange(clientPublicKey))\n            // Send this *unencrypted* as it's the start of the handshake\n            val jsonString = DataModel.Json.encodeToString(DataModel.serializer(), publicKeyExchangeMessage)\n            session?.send(Frame.Text(jsonString))\n            log(\"Client public key sent. Waiting for server public key...\")\n\n            // Start receiving messages (will handle server's public key response)\n            startReceiving()\n\n        } catch (e: Exception) {\n            onError(e)\n            disconnect()\n        }\n    }\n\n    fun disconnect() {\n        receiveJob?.cancel()\n        scope.cancel()\n        session?.cancel()\n        client?.close()\n        onDisconnected()\n        isKeyExchangeComplete = false // Reset key exchange state\n        encryptionManager.clear() // Clear encryption keys\n    }\n\n    suspend fun send(message: DataModel) {\n        try {\n            if (message.messageType is MessageType.PublicKeyExchange || !isKeyExchangeComplete) {\n                // Send public key exchange messages unencrypted, or if encryption isn't ready yet\n                val jsonString = DataModel.Json.encodeToString(DataModel.serializer(), message)\n                session?.send(Frame.Text(jsonString))\n            } else if (encryptionManager.isReady()) {\n                // Encrypt and send as binary frame\n                val jsonString = DataModel.Json.encodeToString(DataModel.serializer(), message)\n                val rawBytes = jsonString.encodeToByteArray()\n                val encryptedBytes = encryptionManager.encrypt(rawBytes)\n                session?.send(Frame.Binary(true, encryptedBytes))\n            } else {\n                // Should not happen if logic is correct, but as a safeguard\n                log(\"Attempted to send encrypted message before key exchange complete.\")\n                onError(IllegalStateException(\"Attempted to send encrypted message before key exchange complete.\"))\n            }\n        } catch (e: Exception) {\n            onError(e)\n        }\n    }\n\n    private fun startReceiving() {\n        receiveJob = scope.launch {\n            try {\n                session?.incoming?.collect {\ frame ->\n                    if (!isKeyExchangeComplete) {\n                        // Handle initial key exchange messages (expected as Text frames)\n                        if (frame is Frame.Text) {\n                            val receivedText = frame.readText()\n                            val dataModel = DataModel.Json.decodeFromString(DataModel.serializer(), receivedText)\n                            if (dataModel.messageType is MessageType.PublicKeyExchange) {\n                                encryptionManager.completeKeyExchange(dataModel.messageType.publicKey)\n                                isKeyExchangeComplete = true\n                                onConnected() // Call onConnected only after encryption is set up\n                                log(\"Key exchange complete. Encryption ready.\")\n                            } else {\n                                log(\"Received unexpected message type during key exchange: ${dataModel.messageType::class.simpleName}\")\n                                onError(IllegalStateException(\"Unexpected message during key exchange\"))\n                                disconnect()\n                            }\n                        } else {\n                            log(\"Received unexpected binary frame during key exchange.\")\n                            onError(IllegalStateException(\"Unexpected binary frame during key exchange\"))\n                            disconnect()\n                        }\n                    } else {\n                        // Key exchange complete, expect encrypted binary frames\n                        val dataModel: DataModel = when (frame) {\n                            is Frame.Binary -> {\n                                if (!encryptionManager.isReady()) {\n                                    onError(IllegalStateException(\"Received binary frame but encryption manager not ready.\"))\n                                    disconnect()\n                                    return@collect\n                                }\n                                val encryptedBytes = frame.readBytes()\n                                val decryptedBytes = encryptionManager.decrypt(encryptedBytes)\n                                val jsonString = decryptedBytes.decodeToString()\n                                DataModel.Json.decodeFromString(DataModel.serializer(), jsonString)\n                            }\n                            is Frame.Text -> {\n                                // This should generally not happen if encryption is fully established for application data.\n                                // However, Ktor WebSockets might still send control frames as text. For application data,\n                                // if we expect encrypted binary, this is likely an error.\n                                log(\"Received unencrypted text frame after key exchange complete. Treating as error.\")\n                                onError(IllegalStateException(\"Received unencrypted text frame after key exchange.\"))\n                                disconnect()\n                                return@collect\n                            }\n                            else -> return@collect // Ignore other frame types\n                        }\n                        log(\"Received: ${dataModel.messageType::class.simpleName}\")\n                        onMessageReceived(dataModel)\n                    }\n                }\n            } catch (e: ClosedReceiveChannelException) {\n                log(\"WebSocket channel closed: ${e.message}\")\n            } catch (e: Exception) {\n                onError(e)\n            } finally {\n                disconnect()\n            }\n        }\n    }\n\n    // Helper for logging\n    private fun log(message: String) {\n        println(\"[KtorClient] $message\")\n    }\n\n    // Example send functions, similar to your old client\n    // These now use the updated `send` function which handles encryption\n    suspend fun sendText(text: String) {\n        send(DataModel(messageType = MessageType.Text(text)))\n    }\n\n    suspend fun sendCommand(command: String, parameters: Map<String, String> = emptyMap()) {\n        send(DataModel(messageType = MessageType.Command(command, parameters)))\n    }\n\n    suspend fun sendMouseMove(x: Int, y: Int) {\n        val message = DataModel(messageType = MessageType.Command(\"mouse_move\", mapOf(\"x\" to x.toString(), \"y\" to y.toString())))\n        send(message)\n    }\n\n    suspend fun sendMouseClick(button: String) {\n        val message = DataModel(messageType = MessageType.Command(\"mouse_click\", mapOf(\"button\" to button)))\n        send(message)\n    }\n\n    suspend fun sendKeyPress(key: String) {\n        val message = DataModel(messageType = MessageType.Command(\"key_press\", mapOf(\"key\" to key)))\n        send(message)\n    }\n}